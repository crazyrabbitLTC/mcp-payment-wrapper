# Implementation Plan: MCP Payment Wrapper Authentication Flow

## Goal:
Implement a simple, stateless authentication flow for the MCP Payment Wrapper, enabling developers to provide their API key and allowing LLM users to authenticate via JWT tokens.

## High-Level Flow Recap:
1. Developer initializes the MCP server wrapped with the payment wrapper, providing their API key.
2. LLM calls a protected tool without a JWT token.
3. Wrapper responds with an authentication-required message and a unique authentication URL containing a UUID.
4. LLM authenticates via backend (out of scope), backend returns JWT token.
5. LLM includes JWT token in subsequent calls; wrapper verifies JWT token with backend.

## Detailed Implementation Steps:

### Step 1: Extend Wrapper Initialization
- **Input**: Developer API key
- **Output**: Wrapper instance associated with developer account
- **Action**:
  - Modify wrapper initialization to accept and store the developer's API key.
  - Register the MCP server instance with the backend using the provided API key.

### Step 2: Handle Unauthenticated Requests
- **Input**: Tool call without JWT token
- **Output**: Authentication-required response with unique URL
- **Action**:
  - Detect missing or invalid JWT token in incoming requests.
  - Generate a UUID (using a reliable UUID library).
  - Construct an authentication URL containing the UUID.
  - Return a structured response clearly indicating authentication is required, including the URL.

### Step 3: Backend JWT Generation (Backend Interaction)
- **Input**: UUID, Developer API key
- **Output**: JWT token (generated by backend)
- **Action**:
  - Initially mock backend JWT generation API.
  - Backend receives UUID and API key.
  - Backend verifies UUID hasn't been used before (one-time use).
  - Backend generates JWT token embedding:
    - Developer API key (to associate JWT with MCP server instance).
    - User identity information (if applicable).
    - Expiration timestamp (initially set to a reasonable default, e.g., 1 hour).
  - Backend returns JWT token to LLM (via wrapper or directly).

### Step 4: JWT Verification on Subsequent Calls
- **Input**: JWT token included in LLM requests
- **Output**: Authorized or unauthorized response
- **Action**:
  - Wrapper forwards JWT token to backend for verification.
  - Backend decodes JWT token and verifies:
    - Token validity and expiration.
    - Developer API key matches the MCP server instance.
  - Wrapper allows or denies the tool call based on backend response.

## Technical Considerations:
- **Statelessness**: No local storage of UUIDs or JWT tokens.
- **UUID Generation**: Use a reliable UUID library (`uuid` npm package).
- **JWT Handling**: JWT tokens generated and verified by backend.
- **Error Handling**: Clear, structured responses for authentication-required and unauthorized scenarios (JSON format).

## Logging and Validation:
- Use the existing logger implementation (avoid `console.log` to prevent interference with MCP using STDIO).
- Log UUID generation and authentication-required responses.
- Log backend JWT verification requests and responses.
- Ensure logs clearly indicate authentication flow steps for debugging.

## Testing Strategy:
- Write tests covering:
  - Wrapper initialization with API key.
  - Unauthenticated requests triggering authentication-required responses.
  - JWT token verification flow (mock backend responses for testing).
- Ensure comprehensive test coverage for all authentication scenarios.

## Implementation Checklist:
- [ ] Extend wrapper initialization to accept API key.
- [ ] Implement UUID generation and authentication-required responses.
- [ ] Implement JWT token forwarding and backend verification (initially mocked).
- [ ] Add detailed logging for each step using the existing logger.
- [ ] Write comprehensive tests for authentication flow.
- [ ] Update documentation clearly explaining the authentication flow.

## Next Steps:
1. Save this detailed implementation plan to an `instructions` file.
2. Create a new branch named `feature/authentication-flow`.
3. Clarify any additional questions or assumptions with you.
4. Obtain your explicit approval before starting implementation. 